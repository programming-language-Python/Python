from django.db import models

# Create your models here.
# title - заголовок объявления, содержащий название продаваемого товара (тип - строковый, длина - 50 символов).
# Поле обязательно к заполнению
# content - сам текст объявления, описание товара (тип - memo)
# price - цена (тип - вещественное число) 
# published - дата публикации (тип - дата и время, значение по умолчанию - текущие дата и время, индексированное)
class Bd(models.Model):
# CharField - обычное строковое поле фиксированной длины. Допустимая длина указывается параметром max_lenght конструктора
    title = models.CharField (max_length=50, verbose_name='Товар')
# TextField - текстовое поле неограниченной длины, или memo-поле. Присвоив параметрам null и blank конструктора значения True,
# мы укажем, что это поле можно не заполнять (по умолчанию любое поле обязательно к заполнению)
    content = models.TextField (null=True, blank=True, verbose_name='Описание')
# FloatField - поле для хранения вещественных чисел. Оно также не обязательно для заполнения
    price = models.FloatField (null=True, blank=True, verbose_name='Цена')
# DateTimeField  - поле для хранения отметки даты и времени. Присвоив паарметру auto_now_add конструктора значение True,
# мы предпишем Django при создании новой записи записывать в это поле текущие дату и время. А параметр db_index при присваивании
# ему значения True укажет создать для этого поля индекс (при выводе объявлений мы будем сортировать их по убыванию даты публикации,
# и индекс здесь очень пригодится)
    published = models.DateTimeField (auto_now_add=True, db_index=True, verbose_name='Опубликовано')
    objects = models.Manager()
    '''
    Класс ForeignКey представляет поле внешнего ключа, в котором фактически будет
    храниться ключ записи из первичной модели. Первым параметром конструктору
    этого класса передается класс первичной модели в виде:
    ссылки на класс - если код, объявляющий класс первичной модели, располагается
    перед кодом класса вторичной модели;
    строки с именем класса - если вторичная модель объявлена раньше первичной
    (как у нас).

    Все поля, создаваемые в моделях, по умолчанию обязательны к заполнению. Следовательно,
    добавить новое, обязательное к заполнению поле в модель, которая
    уже содержит записи, нельзя - сама СУБД откажется делать это и выведет сообщение
    об ошибке. Нам придется явно пометить поле ruЬric как необязательное,
    присвоив параметру null значение тrue - только после этого поле будет успешно
    добавлено в модель.

    Именованный параметр on _ delete управляет каскадными удалениями записей
    вторичной модели после удаления записи первичной модели, с которой они бьmи
    связаны. Значение РRОТЕСТ этого параметра запрещает каскадные удаления (чтобы
    какой-нибудь несообразительный администратор не удалил разом сразу уйму объявлений).
    '''
    rubric = models.ForeignKey ('Rubric', null=True, on_delete=models.PROTECT, verbose_name='Рубрика')
# Сохраним исправленный модуль и выполним генерирование миграций, которые внесут необходимые изменения в структуры базы данных:
# manage.py makemigrations bboard
    class Meta:
# verbose _ narne plural - название модели во множественном числе;
# verbose _ narne - название модели в единственном числе.
# ordering- последовательность полей, по которым по умолчанию будет выполняться сортировка записей.
        verbose_name_plural = 'Объявления'
        verbose_name = 'Объявление'
        ordering = ['published']
# рубрики объявлений
class Rubric(models.Model):
    name = models.CharField(max_length=20, db_index=True, verbose_name='Название')
    objects = models.Manager()
# возращает строковое представление класса
    def __str__(self):
        return self.name
    class Meta:
        verbose_name_plural = 'Рубрики'
        verbose_name = 'Рубрика'
        ordering = ['name']